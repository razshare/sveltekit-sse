export {}

// Shared.

/**
 * @template T
 * @typedef {{[K in keyof T]:T[K]} & {}} Pretty
 */

/**
 * @template T
 * @template [E = Error]
 * @typedef {{value:T,error:false|E}} Unsafe
 */

/**
 * @typedef ClosePayload
 * @property {string} [reason]
 */

/**
 * Describes an event before being serialized.
 * @typedef Event
 * @property {string} id Message identifier, it identifies a message\
 * This value is not globally unique, it is only unique within the current stream's scope.
 * @property {string} event Name of the event.
 * @property {string} data Message data.
 * @property {boolean} isLocal If `true` then this event has been emitted locally, not by the server.
 * @property {number} status The status code of the underlying http response.
 * @property {string} statusText The status text of the underlying http response.
 * @property {Headers} headers The headers of the underlying http response.
 * @property {function():void} connect Connect the stream.
 * @property {Error} [error] Something went wrong.
 * > **Note**\
 * > You can use this whenever the stream disconnects for any reason in order to reconnect.
 *
 * ## Example
 * ```js
 * const quote = source('/events', {
 *    close({ connect }) {
 *     console.log('reconnecting...')
 *     connect()
 *   }
 * })
 * ```
 * @property {function():void} close Close the stream.
 */

/**
 * @typedef {(event:import('./types.external').Event)=>void} EventListener
 */

/**
 * @typedef {(eventName:string,data:string)=>import('./types.external').Unsafe<void>} Emitter
 */

/**
 * @typedef Connection
 * @property {(eventName:string,data:string)=>import('./types.external').Unsafe<void,Error>} emit Emit events to the client.\
 * The result wrapper may contain an error
 * ## Example
 * ```js
 * const {error} = emit('message', 'hello world')
 * if(error){
 *  console.error(error)
 *  return
 * }
 * ```
 * @property {import("svelte/store").Writable<boolean>} lock This store is initialized with `true`,
 * it prevents the underlying `Response` from resolving automatically.\
 * Set it to `false` in order to unlock the `Response` and end the stream immediately.
 *
 * > **Note**\
 * > You shouldn't `emit` any more events after setting the lock to `false`.\
 * > Attempting to emit more data afterwards will result into an error.
 * > ```js
 * > lock.set(false)
 * > const {error} = emit('message', 'hello world')
 * > if(error){
 * >  console.error(error) // "Client disconnected from the stream."
 * >  return
 * > }
 * > ```
 * @property {UnderlyingDefaultSource<string>} source
 */

/**
 * Describes the current parsed json and the previous json values.
 * @template T
 * @typedef JsonPredicatePayload
 * @property {Error} error The error generated by `JSON.parse`.
 * @property {string} raw This is the current raw string value, the one that triggered the error.
 * @property {null|T} previous This is the previous value of the store.
 */

/**
 * @template [T = any]
 * @callback JsonPredicate
 * @param {JsonPredicatePayload<T>} payload
 * @returns {null|T}
 */

/**
 * Options for the underlying http request.
 * @typedef {Pick<import('@microsoft/fetch-event-source').FetchEventSourceInit, "body"|"cache"|"credentials"|"fetch"|"headers"|"integrity"|"keepalive"|"method"|"mode"|"openWhenHidden"|"redirect"|"referrer"|"referrerPolicy"|"window">} Options
 */

// Source.

/**
 * Consume a server sent event as a readable store.
 *
 * > **Note**\
 * > Calling this multiple times using the same `resource` string will not
 * > create multiple streams, instead the same stream will be reused for all exposed
 * > events on the given `resource`.
 * @typedef SourceConfiguration
 * @property {import('./types.external').EventListener} [close] Do something whenever the connection closes.
 * @property {import('./types.external').EventListener} [open] Do something whenever the connection opens.
 * @property {import('./types.external').EventListener} [error] Do something whenever there are errors.
 * @property {import('./types.external').Options} [options] Options for the underlying http request.
 * @property {boolean} [cache] Wether or not to cache connections, defaults to `true`.
 * > **Note**\
 * > Connections are cached based on `from` and `options`.\
 * > If two sources define all three properties with the same values, then both sources will share the same connection,
 * > otherwise they will create and use two separate connections.
 */

/**
 * @template [T = any]
 * @callback SourceSelect
 * @param {string} eventName Name of the event.
 * @returns {import('svelte/store').Readable<string>&SourceSelected<T>}
 */

/**
 * @template [T = any]
 * @callback Transformer
 * @param {string} value
 * @return {T}
 */

/**
 * @template [T = any]
 * @callback Jsonifier
 * @param {import('./types.external').JsonPredicate} [or] Manage the value when the json parsing fails.\
 * Whatever this function returns will become the new value of the store.
 * @returns {import('svelte/store').Readable<null|T>}
 */

/**
 * @template [T = any]
 * @callback SourceSelectedTransform
 * @param {Transformer<T>} transformer
 */

/**
 * @template [T = any]
 * @typedef SourceSelected
 * @property {SourceSelectedTransform<T>} transform Transform the data into a custom shape.
 * @property {Jsonifier<T>} json Parse the data as json.
 */

/**
 * @template [T = any]
 * @typedef Source
 * @property {function():void} close
 * @property {SourceSelect} select Select an event from the stream.
 */

// Produce.

/**
 * @callback OnCancel
 * @param {UnderlyingDefaultSource<string>} stream
 * @returns {void|PromiseLike<void>}
 */

/**
 * @callback Start
 * @param {import('./types.external').Connection} payload
 * @returns {void|Stop|PromiseLike<void>|PromiseLike<Stop>}
 */

/**
 * @callback Stop
 * @param {UnderlyingDefaultSource<string>} stream
 * @returns {void|PromiseLike<void>}
 */

/**
 * @typedef ProducePayload
 * @property {Record<string, string>} [headers] Response headers.
 * @property {number} [ping] The server will ping the client every `interval` milliseconds to check if it's still connected.\
 * If the client has disconnected, the stream will be un`locked` and the connection will terminate.\
 * Defaults to `30_000` milliseconds (`30` seconds).
 * @property {import('./types.external').Stop} [stop] Do something when the stream is stopped.\
 * The following qualify as "stopped"
 * - Calling `.cancel` on the underlying `ReadableStream`
 * - Calling `lock.set(false)`
 * - Client disconnected
 */

// Consume.
